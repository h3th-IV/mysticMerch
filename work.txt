--internal
    | --database
        |--init.go
    | --models
        | --models.go
    | --server
        | --admin_routes.go
        | --products_routes.go
        | --user_routes.go
        | --server.go
    | --utils
        | --utils.go
    | --api
        | --handlers.go



        {
    "product_name": "h4ckerP1",
    "description": "The everything computer. Optimised. With 2-3× the speed of the previous generation, and featuring silicon designed in‑house for the best possible performance, we've redefined the Raspberry Pi experience. Buy Raspberry Pi 5.",
    "image": "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse4.mm.bing.net%2Fth%3Fid%3DOIP.UhNcSbuF9Vszp8Yf4yZACwHaEX%26pid%3DApi&f=1&ipt=952f455d468d9745cf31a2ee8250d85ce07c8dc3a2367c250f6c3beab456d8ea&ipo=images",
    "price": 399.99
}

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOiIyMDI0LTAzLTA3VDAxOjU1OjU3LjEyNDgwNzY4KzAxOjAwIiwiaXNzIjoiTTFfaDN0aC1JVl90TSIsInVzZXIiOiIifQ.9MdqHqSTAksnPFI29Jm44HRJMBz4qutJsmlA3F_oZ7E




func LogIn(w http.ResponseWriter, r *http.Request) {
	//Load env var
	if err := utils.LoadEnv(); err != nil {
		utils.ReplaceLogger.Error("failed to load env variables", zap.Error(err))
		http.Error(w, "operation Failed", http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()

	var Login *models.Login
	if err := json.NewDecoder(r.Body).Decode(&Login); err != nil {
		utils.ReplaceLogger.Error("failed to decode json", zap.Error(err))
		http.Error(w, "failed to decode json object", http.StatusBadRequest)
		return
	}

	user, err := dataBase.AuthenticateUser(Login.Email)
	if err != nil {
		utils.ReplaceLogger.Error("unable to retrieve user details", zap.Error(err))
		http.Error(w, "unable to retrieve details", http.StatusUnauthorized)
		return
	}
	passErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(Login.Password))
	if passErr == bcrypt.ErrMismatchedHashAndPassword && passErr != nil {
		http.Error(w, "password is incorrect", http.StatusUnauthorized)
		return
	}
	var JWToken string
	var tokenErr error
	//create  admin token
	if Login.Email == os.Getenv("NIMDALIAME") {
		JWToken, tokenErr = utils.AdminToken(user, 10*time.Hour, os.Getenv("JWTISSUER"), os.Getenv("MYTH"))
	} else {
		//create user token
		JWToken, tokenErr = utils.GenerateToken(user, 2*time.Hour, os.Getenv("JWTISSUER"), os.Getenv("MYSTIC"))
	}
	if tokenErr != nil {
		utils.ServerError(w, "failed to generate token", tokenErr)
		return
	}
	resopnse := map[string]interface{}{
		"message": "login Succesfully",
		"jwToken": JWToken,
	}
	apiResponse(resopnse, w)
}


// Middleware to Auth specific routes
func JWTAuthRoutes(next http.Handler, secret string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		//get JWToken from request
		JWToken := r.Header.Get("Authorization")
		token, err := jwt.Parse(JWToken, func(t *jwt.Token) (interface{}, error) {
			return []byte(secret), nil
		})

		if err != nil || !token.Valid {
			http.Error(w, "Unauthorized Operation", http.StatusUnauthorized)
			return
		}
		tokenClaims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			http.Error(w, "Invalid Token claims", http.StatusBadRequest)
			return
		}

		userID, ok := tokenClaims["user_id"]
		if !ok {
			http.Error(w, "User is not Authorized", http.StatusBadRequest)
			return
		}

		//store user_id in context
		ctx := context.WithValue(r.Context(), UserIDkey, userID)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}


// admin stuff
func AddItemtoStore(w http.ResponseWriter, r *http.Request) {
	//test
	_, err := fmt.Println("admin logger here")
	if err != nil {
		log.Println("err", err)
		return
	}
	//get Admin id
	uuid := r.Context().Value(utils.UserIDkey).(string)
	fmt.Println(uuid)
	user, err := dataBase.GetUserbyUUID(uuid)
	fmt.Println(user.ID, user.Email, user.LastName)
	if err != nil {
		http.Error(w, "user not authenticated", http.StatusNetworkAuthenticationRequired)
		return
	}
	fmt.Println(user.ID)
	if user.ID != 1 {
		http.Error(w, "user not authorised", http.StatusUnauthorized)
		return
	}
	//decode new item
	var Product *models.NewProduct
	if err := json.NewDecoder(r.Body).Decode(&Product); err != nil {
		utils.ReplaceLogger.Error("failed to decode json", zap.Error(err))
		http.Error(w, "failed to decode json", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()
	//add product to database
	_, err = dataBase.AddProduct(user.ID, Product.ProductName, Product.Description, Product.Image, Product.Price)
	if err != nil {
		utils.ReplaceLogger.Error("failed to add product", zap.Error(err))
		utils.ServerError(w, "failed to add product to store", err)
		return
	}

	//write and send response
	response := map[string]interface{}{
		"message": "operation was succesfull",
	}
	apiResponse(response, w)
}